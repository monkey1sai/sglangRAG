<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WD Gateway TTS Web Client Reference (v1)</title>
    <style>
      :root {
        --bg: #0b0f17;
        --card: #111827;
        --muted: #94a3b8;
        --text: #e5e7eb;
        --border: #1f2937;
        --accent: #60a5fa;
        --danger: #f87171;
        --ok: #34d399;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
        background: radial-gradient(1200px 600px at 20% 0%, #0b1224, var(--bg));
        color: var(--text);
      }
      a {
        color: var(--accent);
      }
      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 20px;
      }
      h1 {
        margin: 8px 0 12px;
        font-size: 20px;
        font-weight: 650;
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.5;
      }
      .grid {
        display: grid;
        grid-template-columns: 1.1fr 0.9fr;
        gap: 16px;
      }
      .card {
        background: color-mix(in srgb, var(--card) 90%, transparent);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 14px;
      }
      .row {
        display: grid;
        grid-template-columns: 160px 1fr;
        gap: 10px;
        align-items: center;
        margin: 10px 0;
      }
      label {
        color: var(--muted);
        font-size: 12px;
      }
      input,
      select,
      textarea {
        width: 100%;
        box-sizing: border-box;
        background: #0b1224;
        border: 1px solid var(--border);
        border-radius: 10px;
        color: var(--text);
        padding: 10px 10px;
        outline: none;
      }
      textarea {
        min-height: 160px;
        resize: vertical;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        line-height: 1.5;
      }
      .btns {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 8px;
      }
      button {
        border: 1px solid var(--border);
        background: #0b1224;
        color: var(--text);
        padding: 10px 12px;
        border-radius: 10px;
        cursor: pointer;
      }
      button.primary {
        background: color-mix(in srgb, var(--accent) 18%, #0b1224);
        border-color: color-mix(in srgb, var(--accent) 35%, var(--border));
      }
      button.danger {
        background: color-mix(in srgb, var(--danger) 15%, #0b1224);
        border-color: color-mix(in srgb, var(--danger) 30%, var(--border));
      }
      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 12px;
        color: var(--muted);
      }
      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--muted);
      }
      .dot.ok {
        background: var(--ok);
      }
      .dot.bad {
        background: var(--danger);
      }
      pre {
        white-space: pre-wrap;
        word-break: break-word;
        background: #0b1224;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        margin: 0;
        font-size: 12px;
        line-height: 1.5;
        max-height: 360px;
        overflow: auto;
      }
      .mini {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .kvs {
        display: grid;
        grid-template-columns: 140px 1fr;
        gap: 6px 10px;
        font-size: 12px;
        line-height: 1.55;
      }
      .kvs .k {
        color: var(--muted);
      }
      .warn {
        color: #fbbf24;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>WD Orchestrator Web Client Reference（LLM → TTS, WS API v1）</h1>
      <div class="hint">
        <div>此頁面只做最小可用與除錯，不追求 UI。TTS 訊息格式完全遵守 `docs/API.md` 的 WS API v1。</div>
        <div>
          Browser 原生 WebSocket 無法自訂 `Authorization` header；本工具會把 `API Key` 附加到 URL query（例如
          `?api_key=...`）。若你的部署要求 header 認證，請在 Nginx/Ingress 層注入。
        </div>
      </div>

      <div class="grid" style="margin-top: 14px">
        <div class="card">
          <div class="row">
            <label>Orchestrator URL</label>
            <input id="orchestratorUrl" value="" placeholder="預設：ws(s)://<host>/chat" />
          </div>
          <div class="row">
            <label>API Key（可留空）</label>
            <input id="apiKey" placeholder="可留空；會附加到 ?api_key=" />
          </div>
          <div class="row">
            <label>Session ID</label>
            <input id="sessionId" />
          </div>

          <div class="mini">
            <div class="row" style="grid-template-columns: 160px 1fr">
              <label>audio_format</label>
              <select id="audioFormat">
                <option value="pcm16_wav" selected>pcm16_wav</option>
              </select>
            </div>
            <div class="row" style="grid-template-columns: 160px 1fr">
              <label>sample_rate</label>
              <select id="sampleRate">
                <option value="16000" selected>16000</option>
                <option value="22050">22050</option>
                <option value="24000">24000</option>
                <option value="48000">48000</option>
              </select>
            </div>
          </div>

          <div class="mini">
            <div class="row" style="grid-template-columns: 160px 1fr">
              <label>channels</label>
              <select id="channels">
                <option value="1" selected>1</option>
                <option value="2">2</option>
              </select>
            </div>
            <div></div>
          </div>

          <div class="btns">
            <button class="primary" id="btnConnect">Connect</button>
            <button class="danger" id="btnDisconnect" disabled>Disconnect</button>
            <span class="pill" title="WebSocket 連線狀態">
              <span id="connDot" class="dot"></span>
              <span id="connText">DISCONNECTED</span>
            </span>
          </div>

          <div class="row" style="grid-template-columns: 160px 1fr; margin-top: 14px">
            <label>輸入問題</label>
            <textarea id="inputText" placeholder="輸入問題後按 Send prompt（會串流顯示文字，並同步產音播放）。"></textarea>
          </div>

          <div class="btns">
            <button class="primary" id="btnSendPrompt" disabled>Send prompt</button>
            <button class="danger" id="btnCancel" disabled>Cancel</button>
            <button id="btnClearLog">Clear log</button>
          </div>

          <div class="hint" style="margin-top: 10px">
            <div>
              播放策略：使用 WebAudio 播放 `audio_chunk.audio_base64`（raw PCM16 little-endian）。`wav_header_base64` 僅用於除錯顯示/驗證格式。
            </div>
            <div class="warn">注意：若 chunk 產生粒度較大或標點密度低，UnitLatency 可能出現長尾（屬正常現象）。</div>
          </div>
        </div>

        <div class="card">
          <div class="kvs">
            <div class="k">session_id</div>
            <div id="dbgSessionId">-</div>
            <div class="k">seq（tts）</div>
            <div id="dbgSeq">-</div>
            <div class="k">TTFA</div>
            <div id="dbgTtfa">-</div>
            <div class="k">chunks（收到）</div>
            <div id="dbgChunks">0</div>
            <div class="k">last chunk_seq</div>
            <div id="dbgChunkSeq">-</div>
            <div class="k">last unit range</div>
            <div id="dbgUnitRange">-</div>
            <div class="k">errors（收到）</div>
            <div id="dbgErrors">0</div>
          </div>
          <div style="margin-top: 12px; display: grid; gap: 10px">
            <div>
              <div class="hint" style="margin-bottom: 6px">Last start_ack</div>
              <pre id="preStartAck">(none)</pre>
            </div>
            <div>
              <div class="hint" style="margin-bottom: 6px">LLM transcript</div>
              <pre id="preLlm"></pre>
            </div>
            <div>
              <div class="hint" style="margin-bottom: 6px">Event log</div>
              <pre id="preLog"></pre>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id);

      function randomUuidV4() {
        // RFC4122 v4
        const bytes = crypto.getRandomValues(new Uint8Array(16));
        bytes[6] = (bytes[6] & 0x0f) | 0x40;
        bytes[8] = (bytes[8] & 0x3f) | 0x80;
        const hex = Array.from(bytes, (b) => b.toString(16).padStart(2, "0")).join("");
        return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
      }

      function nowMs() {
        return performance.now();
      }

      function safeJson(obj) {
        return JSON.stringify(obj, null, 2);
      }

      function log(line, obj) {
        const ts = new Date().toISOString().slice(11, 23);
        const msg = obj ? `${ts} ${line}\n${safeJson(obj)}\n` : `${ts} ${line}\n`;
        const pre = $("preLog");
        pre.textContent = msg + pre.textContent;
      }

      function buildWsUrl(baseUrl, apiKey) {
        if (!apiKey) return baseUrl;
        try {
          const u = new URL(baseUrl);
          u.searchParams.set("api_key", apiKey);
          return u.toString();
        } catch {
          const sep = baseUrl.includes("?") ? "&" : "?";
          return `${baseUrl}${sep}api_key=${encodeURIComponent(apiKey)}`;
        }
      }

      function defaultOrchestratorWsUrl() {
        const wsProto = window.location.protocol === "https:" ? "wss:" : "ws:";
        return `${wsProto}//${window.location.host}/chat`;
      }

      async function tryAutoPickSampleRate() {
        try {
          const resp = await fetch("/tts/healthz", { cache: "no-store" });
          if (!resp.ok) return;
          const obj = await resp.json();
          const sr = obj?.model_sample_rate;
          if (typeof sr !== "number") return;
          const select = $("sampleRate");
          const has = Array.from(select.options).some((o) => Number(o.value) === sr);
          if (has) {
            select.value = String(sr);
            log(`auto sample_rate from /tts/healthz: ${sr}`);
          }
        } catch {
          // ignore
        }
      }

      function b64ToBytes(b64) {
        const bin = atob(b64);
        const bytes = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
        return bytes;
      }

      function bytesStartWithAscii(bytes, ascii) {
        if (bytes.length < ascii.length) return false;
        for (let i = 0; i < ascii.length; i++) {
          if (bytes[i] !== ascii.charCodeAt(i)) return false;
        }
        return true;
      }

      function parseWavPcm16(bytes) {
        // Minimal WAV parser for PCM16LE. Supports typical "RIFF....WAVE" layout with "fmt " and "data".
        if (!bytesStartWithAscii(bytes, "RIFF")) throw new Error("not a RIFF wav");
        if (bytes.length < 44) throw new Error("wav too small");

        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        const waveMark =
          String.fromCharCode(bytes[8], bytes[9], bytes[10], bytes[11]) === "WAVE";
        if (!waveMark) throw new Error("not a WAVE file");

        let offset = 12;
        let fmt = null;
        let data = null;

        while (offset + 8 <= bytes.byteLength) {
          const id = String.fromCharCode(bytes[offset], bytes[offset + 1], bytes[offset + 2], bytes[offset + 3]);
          const size = view.getUint32(offset + 4, true);
          const payloadStart = offset + 8;
          const payloadEnd = payloadStart + size;
          if (payloadEnd > bytes.byteLength) break;

          if (id === "fmt ") {
            if (size < 16 || payloadStart + 16 > bytes.byteLength) throw new Error("wav invalid fmt chunk");
            const audioFormat = view.getUint16(payloadStart + 0, true);
            const channels = view.getUint16(payloadStart + 2, true);
            const sampleRate = view.getUint32(payloadStart + 4, true);
            const bitsPerSample = view.getUint16(payloadStart + 14, true);
            fmt = { audioFormat, channels, sampleRate, bitsPerSample };
          } else if (id === "data") {
            data = bytes.slice(payloadStart, payloadEnd);
          }

          offset = payloadEnd + (size % 2); // chunks are word-aligned
          if (fmt && data) break;
        }

        if (!fmt) throw new Error("wav missing fmt chunk");
        if (!data) throw new Error("wav missing data chunk");
        if (fmt.audioFormat !== 1) throw new Error(`wav unsupported audioFormat=${fmt.audioFormat}`);
        if (fmt.bitsPerSample !== 16) throw new Error(`wav unsupported bitsPerSample=${fmt.bitsPerSample}`);

        return { pcm16Bytes: data, sampleRate: fmt.sampleRate, channels: fmt.channels };
      }

      function pcm16leToFloat32(bytes) {
        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        const sampleCount = Math.floor(bytes.byteLength / 2);
        const out = new Float32Array(sampleCount);
        for (let i = 0; i < sampleCount; i++) {
          const s = view.getInt16(i * 2, true);
          out[i] = s / 32768;
        }
        return out;
      }

      class AudioPlayer {
        constructor() {
          this.ctx = null;
          this.nextTime = 0;
          this.started = false;
          this.queueDepth = 0;
          this.maxQueueSeconds = 6.0;
        }

        ensure(sampleRate) {
          if (this.ctx) return;
          this.ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate });
          this.nextTime = this.ctx.currentTime;
          this.started = true;
        }

        async resume() {
          if (!this.ctx) return;
          if (this.ctx.state === "suspended") {
            await this.ctx.resume();
          }
        }

        reset() {
          if (this.ctx) {
            try {
              this.ctx.close();
            } catch {}
          }
          this.ctx = null;
          this.nextTime = 0;
          this.started = false;
          this.queueDepth = 0;
        }

        enqueuePcm16({ pcm16Bytes, sampleRate, channels }) {
          this.ensure(sampleRate);
          if (!this.ctx) return;

          const floats = pcm16leToFloat32(pcm16Bytes);
          const frameCount = Math.floor(floats.length / channels);
          const buffer = this.ctx.createBuffer(channels, frameCount, sampleRate);

          for (let ch = 0; ch < channels; ch++) {
            const channelData = buffer.getChannelData(ch);
            for (let i = 0; i < frameCount; i++) {
              channelData[i] = floats[i * channels + ch] || 0;
            }
          }

          const duration = buffer.duration;
          const queuedSeconds = Math.max(0, this.nextTime - this.ctx.currentTime);
          if (queuedSeconds > this.maxQueueSeconds) {
            throw new Error(`Audio queue too deep (${queuedSeconds.toFixed(2)}s)`);
          }

          const src = this.ctx.createBufferSource();
          src.buffer = buffer;
          src.connect(this.ctx.destination);

          const startAt = Math.max(this.nextTime, this.ctx.currentTime + 0.02);
          src.start(startAt);
          this.nextTime = startAt + duration;
          this.queueDepth++;
        }
      }

      const audioPlayer = new AudioPlayer();

      let ws = null;
      let sessionId = randomUuidV4();
      let startSentAtMs = null;
      let ttfaMs = null;
      let chunksReceived = 0;
      let errorsReceived = 0;
      let lastTtsSeq = null;

      function setConnState(state) {
        $("connText").textContent = state;
        const dot = $("connDot");
        dot.classList.remove("ok", "bad");
        if (state === "CONNECTED") dot.classList.add("ok");
        if (state === "ERROR") dot.classList.add("bad");
      }

      function setUiConnected(connected) {
        $("btnConnect").disabled = connected;
        $("btnDisconnect").disabled = !connected;
        $("btnSendPrompt").disabled = !connected;
        $("btnCancel").disabled = !connected;
        $("orchestratorUrl").disabled = connected;
        $("apiKey").disabled = connected;
        $("sessionId").disabled = connected;
        $("audioFormat").disabled = connected;
        $("sampleRate").disabled = connected;
        $("channels").disabled = connected;
      }

      function updateDebug() {
        $("dbgSessionId").textContent = sessionId || "-";
        $("dbgSeq").textContent = lastTtsSeq == null ? "-" : String(lastTtsSeq);
        $("dbgTtfa").textContent = ttfaMs == null ? "-" : `${ttfaMs.toFixed(0)} ms`;
        $("dbgChunks").textContent = String(chunksReceived);
        $("dbgErrors").textContent = String(errorsReceived);
      }

      function wsSend(obj) {
        if (!ws || ws.readyState !== WebSocket.OPEN) throw new Error("WebSocket not open");
        ws.send(JSON.stringify(obj));
        log("→ send", obj);
      }

      function buildCancel() {
        return { type: "cancel" };
      }

      function resetSessionState() {
        startSentAtMs = null;
        ttfaMs = null;
        chunksReceived = 0;
        errorsReceived = 0;
        lastTtsSeq = null;
        $("preStartAck").textContent = "(none)";
        $("preLlm").textContent = "";
        updateDebug();
        audioPlayer.reset();
      }

      function applySessionIdFromUi() {
        const v = $("sessionId").value.trim();
        sessionId = v || randomUuidV4();
        $("sessionId").value = sessionId;
        $("dbgSessionId").textContent = sessionId;
      }

      $("btnClearLog").addEventListener("click", () => {
        $("preLog").textContent = "";
      });

      $("btnConnect").addEventListener("click", async () => {
        try {
          applySessionIdFromUi();
          resetSessionState();
          // Autoplay policy: 建議在「使用者手勢」內建立並 resume AudioContext，避免後續 onmessage 才建立導致無聲。
          audioPlayer.ensure(Number($("sampleRate").value));
          await audioPlayer.resume();

          const url = buildWsUrl($("orchestratorUrl").value.trim(), $("apiKey").value.trim());
          ws = new WebSocket(url);
          setConnState("CONNECTING");
          setUiConnected(true);
          log(`connect: ${url}`);

          ws.onopen = () => {
            setConnState("CONNECTED");
            updateDebug();
          };

          ws.onmessage = (ev) => {
            let msg;
            try {
              msg = JSON.parse(ev.data);
            } catch {
              log("← message (non-json)", { data: String(ev.data).slice(0, 2000) });
              return;
            }
            log("← recv", msg);

            if (msg.type === "orchestrator_start") {
              return;
            }

            if (msg.type === "llm_delta") {
              $("preLlm").textContent += msg.delta || "";
              return;
            }

            if (msg.type === "tool_calls_delta") {
              return;
            }

            if (msg.type === "llm_done") {
              return;
            }

            if (msg.type === "start_ack") {
              $("preStartAck").textContent = safeJson(msg);
              if (typeof msg.seq === "number") lastTtsSeq = msg.seq;
              updateDebug();
              return;
            }

            if (msg.type === "audio_chunk") {
              chunksReceived++;
              if (typeof msg.seq === "number") lastTtsSeq = msg.seq;
              $("dbgChunkSeq").textContent = String(msg.chunk_seq ?? "-");
              $("dbgUnitRange").textContent = `${msg.unit_index_start ?? "-"}..${msg.unit_index_end ?? "-"}`;

              if (ttfaMs == null && startSentAtMs != null) {
                ttfaMs = nowMs() - startSentAtMs;
              }

              try {
                const bytes = b64ToBytes(msg.audio_base64 || "");
                const fallbackSampleRate = Number(msg.sample_rate || $("sampleRate").value);
                const fallbackChannels = Number(msg.channels || $("channels").value);

                // v1 定義：pcm16_wav 時 audio_base64 仍多半是 raw PCM16。
                // 但為了相容部分實作可能直接送整段 WAV，這裡做 RIFF/WAVE 偵測並轉成 PCM16 播放。
                if (bytesStartWithAscii(bytes, "RIFF")) {
                  const wav = parseWavPcm16(bytes);
                  audioPlayer.enqueuePcm16(wav);
                } else {
                  audioPlayer.enqueuePcm16({
                    pcm16Bytes: bytes,
                    sampleRate: fallbackSampleRate,
                    channels: fallbackChannels,
                  });
                }
              } catch (e) {
                errorsReceived++;
                log(`audio playback error: ${String(e)}`);
              }
              updateDebug();
              return;
            }

            if (msg.type === "tts_end") {
              log("tts_end received; server will close");
              if (typeof msg.seq === "number") lastTtsSeq = msg.seq;
              updateDebug();
              return;
            }

            if (msg.type === "error") {
              errorsReceived++;
              if (typeof msg.seq === "number") lastTtsSeq = msg.seq;
              updateDebug();
              return;
            }

            if (msg.type === "orchestrator_error") {
              errorsReceived++;
              updateDebug();
              return;
            }

            if (msg.type === "orchestrator_cancelled") {
              return;
            }
          };

          ws.onerror = () => {
            setConnState("ERROR");
          };

          ws.onclose = () => {
            log("ws closed");
            setConnState("DISCONNECTED");
            setUiConnected(false);
            ws = null;
          };
        } catch (e) {
          log(`connect failed: ${String(e)}`);
          setConnState("ERROR");
          setUiConnected(false);
          ws = null;
        }
      });

      $("btnDisconnect").addEventListener("click", () => {
        try {
          if (ws) ws.close();
        } catch {}
      });

      $("btnSendPrompt").addEventListener("click", async () => {
        const prompt = $("inputText").value;
        if (!prompt) return;
        try {
          resetSessionState();
          audioPlayer.ensure(Number($("sampleRate").value));
          await audioPlayer.resume();
          startSentAtMs = nowMs();
          wsSend({
            prompt,
            session_id: sessionId,
            audio_format: $("audioFormat").value,
            sample_rate: Number($("sampleRate").value),
            channels: Number($("channels").value),
          });
          updateDebug();
        } catch (e) {
          log(`send prompt failed: ${String(e)}`);
        }
      });

      $("btnCancel").addEventListener("click", () => {
        try {
          wsSend(buildCancel());
          updateDebug();
        } catch (e) {
          log(`send cancel failed: ${String(e)}`);
        }
      });

      // init
      if (!$("orchestratorUrl").value.trim()) {
        $("orchestratorUrl").value = defaultOrchestratorWsUrl();
      }
      tryAutoPickSampleRate();
      $("sessionId").value = sessionId;
      updateDebug();
      setConnState("DISCONNECTED");
      setUiConnected(false);
    </script>
  </body>
</html>
